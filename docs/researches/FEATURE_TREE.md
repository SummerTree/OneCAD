# Gemini Research

Advanced Architectural Implementation of Parametric Feature History Trees in C++ CAD Systems1. Executive SummaryThe development of modern Computer-Aided Design (CAD) software requires a fundamental shift from static geometric representation to dynamic, history-based parametric modeling. This paradigm relies on the Feature History Tree, a sophisticated data structure that functions not merely as a sequential list of operations, but as a complex Directed Acyclic Graph (DAG) of dependencies. This report provides an exhaustive technical analysis of the software architecture required to implement such a system in C++, specifically leveraging the OpenCascade Technology (OCCT) kernel.The analysis dissects the core components of parametric history management: the procedural regeneration engine, the persistent data framework, and the critical algorithmic solutions to the Topological Naming Problem (TNP). By examining advanced open-source implementations—specifically the Realthunder branch of FreeCAD and the Active Data framework of Analysis Situs—this report synthesizes a blueprint for a robust, industrial-grade CAD architecture. Key findings highlight the necessity of graph-based topological hashing over index-based referencing, the utility of the Command and Factory design patterns for feature orchestration, and the distinct advantages of the Open CASCADE Application Framework (OCAF) as a specialized Entity-Component-System (ECS) for engineering data. Furthermore, the report explores the integration of modern serialization standards, including glTF with metadata, to ensure interoperability in distributed engineering environments.2. Theoretical Foundations of Parametric Modeling2.1 The Evolution from B-Rep to Procedural HistoryTo understand the architectural requirements of a feature history tree, one must first distinguish between the geometric kernel and the parametric engine. The geometric kernel (e.g., OCCT, Parasolid, ACIS) manages the Boundary Representation (B-Rep)—the topological definition of solids using vertices, edges, faces, and shells.1 In a direct modeling paradigm, the software interacts directly with these B-Rep entities, pushing and pulling faces to modify geometry. While intuitive, this approach is destructive; the "intent" of the design is lost the moment the operation is completed.Parametric modeling introduces a meta-layer above the B-Rep: the Feature History. In this paradigm, the B-Rep is merely a transient artifact, a cached result of executing a "recipe".2 The "Model" is no longer the shape itself, but the sequence of algorithms and parameters used to generate it. This shift demands a rigorous software architecture capable of serializing operations (features), managing their inputs (parameters), and orchestrating their execution (regeneration).3The industry has converged on a hybrid approach known as Procedural Feature-Based Modeling. Unlike pure variational systems, which solve a global system of equations for the entire 3D body, procedural systems execute features sequentially.4 However, the relationships between these features are variational and topological. For instance, a "Fillet" feature depends on specific edges generated by a preceding "Extrusion" feature. The C++ architecture must therefore bridge the gap between the procedural logic of the application (Feature A runs before Feature B) and the topological reality of the kernel (Edge ID 452 is replaced by Face ID 901).52.2 The Directed Acyclic Graph (DAG) TopologyWhile user interfaces typically present the history as a linear "tree," the underlying data structure is invariably a Directed Acyclic Graph (DAG).6 This distinction is critical for partial regeneration and dependency management.Nodes: Represent discrete features (e.g., Sketch, Pad, Pocket, Boolean Cut) or auxiliary datum elements (Planes, Axes).Edges: Represent data dependencies. An edge $E_{A \to B}$ exists if Feature B consumes the output of Feature A.The "Acyclic" constraint is inviolable. A cycle (e.g., Feature A defines the placement of Feature B, which determines the dimension of Feature A) would induce an infinite regeneration loop, crashing the solver.6 C++ implementations must enforce this invariant during the link creation phase using cycle detection algorithms such as Depth-First Search (DFS) or Kahn's Algorithm for topological sorting.7Mathematical formalism helps clarify the regeneration scope. Let $G = (V, E)$ be the dependency graph. If a parameter $p$ in node $v_i \in V$ is modified, the system need not regenerate the entire graph. Instead, it must identify the Affected Subgraph $G' \subseteq G$, defined as the set of all descendants of $v_i$:$$G' = \{ v_j \in V \mid \exists \text{ path from } v_i \text{ to } v_j \}$$Efficient identification of $G'$ is the key to high-performance CAD interaction. In systems like "grunk," this is handled via lazy evaluation, where nodes invalidate their cache upon input modification, but only recompute when their value is explicitly queried.52.3 Constructive Solid Geometry (CSG) vs. B-Rep OperationsThe history tree must abstract diverse geometric operations into a unified IFeature interface.CSG Operations: Boolean unions, intersections, and differences. These are mathematically rigorous but computationally expensive if not optimized.Sweeping Operations: Extrusions (Pads), Revolves, and Lofts. These generate topology from 1D or 2D profiles.Dress-up Features: Fillets and Chamfers. These are distinct because they modify existing topology rather than creating new global shapes. They are particularly sensitive to the Topological Naming Problem because they reference unstable entity IDs (e.g., "Edge 12").23. C++ Architectural Patterns for Feature ManagementBuilding a CAD system in C++ requires a synthesis of specific design patterns to handle the complexity of object lifecycle, execution command history, and event propagation.3.1 The Command Pattern for Transactional IntegrityParametric design is inherently transactional. Users expect to experiment with parameters and revert changes if the result is invalid (e.g., a fillet radius that consumes the entire edge). The Command Design Pattern is the standard solution.8Command Interface: Defines Execute(), UnExecute(), and Redo() methods.ConcreteCommand Classes: encapsulate specific operations, such as CmdCreateBox or CmdModifyFillet.State Capture: To support UnExecute, the command must store either the "Inverse Operation" (mathematically difficult in B-Rep) or the "Previous State" (Memento).Integration with OCAF: In the OpenCascade Application Framework (OCAF), this pattern is internalized via the TDocStd_Transaction mechanism. OCAF does not store deep copies of the model for every undo step. Instead, it records Deltas—changes to attributes (e.g., a float value changing from 10.0 to 12.0, or a reference switching labels).9 This allows for an efficient, multi-level undo/redo stack without massive memory overhead.3.2 The Factory Pattern for ExtensibilityA CAD system must be extensible, allowing third-party developers or internal teams to add new feature types (e.g., a specialized "Gear" generator) without recompiling the core kernel. The Factory Method Pattern facilitates this.10Plugin Architecture: As demonstrated in the "grunk" framework, features are implemented in separate libraries.5Registration: A singleton FeatureFactory maintains a map of std::string identifiers (e.g., "Plugin::GearFeature") to function pointers or creator objects.Runtime Instantiation: When opening a file, the persistence layer reads the string ID "Plugin::GearFeature" and asks the Factory to instantiate the corresponding C++ class. This decouples the serialization format from the runtime class hierarchy.3.3 The Observer Pattern for Dirty PropagationThe mechanism that drives the DAG update is the Observer Pattern, often implemented as a "Signal/Slot" system (as in Qt or Analysis Situs).12Subject: The upstream dependency (e.g., a Sketch Object).Observer: The downstream feature (e.g., a Pad Object).Signaling: When the Sketch changes (e.g., CmdModifySketch finishes), it emits a Changed() signal.Propagation Logic: The Pad, observing this signal, sets its internal state to Dirty or Invalid. Critically, it does not immediately regenerate. This Pull-Based Lazy Evaluation is crucial for performance. If a user modifies the sketch 10 times in quick succession, the Pad should only regenerate once—when the final geometry is requested for rendering.53.4 Data Structures: The Graph ImplementationWhile C++ Standard Library containers (std::map, std::vector) are sufficient for basic graphs, CAD systems often require specialized structures to handle the "Document Object Model" (DOM).Adjacency Lists: Efficient for traversing dependencies. std::map<NodeID, std::vector<NodeID>>.Smart Pointers: Usage of std::shared_ptr for node ownership and std::weak_ptr for back-references (children pointing to parents) is mandatory to prevent circular reference memory leaks.14Boost Graph Library (BGL): While powerful, BGL is often too heavy for the specific needs of a CAD feature tree. Custom lightweight graph classes, as seen in Analysis Situs's ActData_DependencyGraph, allow for tighter integration with the OCAF label structure.154. OpenCascade Application Framework (OCAF) ArchitectureFor C++ developers utilizing the OpenCascade kernel, OCAF offers a sophisticated infrastructure that acts as a specialized Entity-Component-System (ECS) for CAD data. It provides the backbone for managing the Feature History Tree, separating data persistence from algorithmic logic.94.1 The OCAF Data Framework: Labels and AttributesOCAF organizes data not as a hierarchy of C++ objects, but as a tree of Labels (TDF_Label), to which Attributes (TDF_Attribute) are attached. This is functionally identical to an ECS architecture used in game development:Entity: The TDF_Label (addressable via an Entry string like 0:1:2).Component: The TDF_Attribute.Data Components: TDataStd_Integer, TDataStd_Real, TDataStd_Name.Graph Components: TDataStd_Reference, TDataStd_TreeNode.Geometric Components: TNaming_NamedShape.18This architecture allows for extreme flexibility. A "Pad" feature is simply a Label with a Name attribute ("Pad1"), a Real attribute (Length), a Reference attribute (pointing to a Sketch), and a NamedShape attribute (storing the cached result).194.2 Handling Topology History with TNamingThe TNaming package is OCCT's native solution for tracking topological evolution, a critical requirement for history management.Evolution Types: TNaming_NamedShape records the history of shape modifications using four enums:PRIMITIVE: New geometry (e.g., BRepPrimAPI_MakeBox).GENERATED: Topology created from other topology (e.g., an extrusion face generated from a profile edge).MODIFY: Topology that replaces old topology (e.g., a face split in two).DELETE: Topology removed (e.g., material cut away).18The Builder Pattern: The TNaming_Builder class is used inside feature algorithms to populate this history.C++// Example C++ implementation of a Cut Feature
TNaming_Builder Builder(ResultLabel);
BRepAlgoAPI_Cut CutAlgo(BaseShape, ToolShape);
CutAlgo.Build();

// Register evolution
TopTools_ListOfShape ModifiedFaces = CutAlgo.Modified(OriginalFace);
for (auto& NewFace : ModifiedFaces) {
    Builder.Modify(OriginalFace, NewFace); // Record evolution
}
This registration builds a "History Graph" parallel to the "Dependency Graph," allowing the system to trace geometric lineage.184.3 The Naming SelectorDownstream features, such as fillets, must reference specific topological entities (e.g., "Edge 12"). OCAF provides TNaming_Selector and TNaming_Tool for this purpose.Selection: The user selects an edge in the viewer. The TNaming_Selector identifies the TNaming_NamedShape attribute that created it and stores a persistent reference.Migration: During regeneration, TNaming_Tool attempts to "migrate" the selection. It looks at the history recorded by TNaming_Builder to find what "Edge 12" has become (e.g., "Edge 12_modified").19However, reliance on pure OCAF naming is often insufficient for complex parametric models, leading to the infamous Topological Naming Problem.5. The Topological Naming Problem (TNP)The Topological Naming Problem (TNP) is the most significant architectural challenge in parametric CAD. It manifests when a change in upstream parameters alters the topological graph (number of faces/edges) of the model, causing downstream references to resolve incorrectly or fail.215.1 Failure MechanicsConsider a simple block with a Fillet on Edge 5.Initial State: The block has 12 edges. The internal index "5" refers to a vertical edge.Modification: A "Cut" feature is inserted before the Fillet. It cuts a corner of the block.Regeneration: The B-Rep is rebuilt. The block now has 15 edges. The OCCT kernel, being deterministic but topology-dependent, re-indexes the edges. The edge at index "5" might now be on the bottom face, or it might be the edge created by the cut.Result: The Fillet jumps to the wrong location or fails because the geometry at index 5 is invalid for filleting.Standard B-Rep kernels (OCCT, Parasolid) do not preserve entity identity across regenerations. TopoDS_Shape objects are transient; they are destroyed and recreated with every Build() call.235.2 Case Study: FreeCAD and the Realthunder AlgorithmFreeCAD, an open-source parametric modeler, historically struggled with TNP. The "Realthunder" branch introduced a comprehensive solution that is now the gold standard for open-source implementations.245.2.1 The ElementMap Data StructureRealthunder introduced a persistent data structure, the ElementMap, into the geometric data class ComplexGeoData.Purpose: Decouples the Transient Index (which changes) from the Persistent Name (which is stable).Mapping: Map<PersistentID, TransientIndex>.API: Features interact with geometry using the PersistentID. The map resolves this to the current OCAF index during execution.255.2.2 Graph-Based Topological HashingThe core innovation is the naming algorithm itself. Instead of indexing, it uses Contextual Hashing.Ancestry Tracing: An entity is named by the history of features that created it (e.g., Pad001_Face).Neighbor Connectivity: If a face is split, the resulting fragments are distinguished by their neighbors.Example: "Face bounded by (Edge_Top, Edge_Left, Edge_Cut)".The hash is a composite of the neighbor's hashes. This recursive definition anchors the name in the topology graph. Even if the internal ID changes, the relationship between the face and its "Top Edge" typically remains consistent.24Salt: If topological hashing is ambiguous (e.g., highly symmetric parts), geometric hints (center of mass, orientation) are used as a "salt" to disambiguate.5.2.3 The Matching HeuristicDuring regeneration, the system employs a three-tier matching strategy 24:Exact Match: Checks if the persistent name exists in the new topology (unmodified entities).Generated/Modified Match: Queries the TNaming logs to trace explicit modifications.Inference: For unnamed new entities, it attempts to deduce identity based on the "Contextual Hash" of surrounding named entities. If 3 out of 4 surrounding edges match a known pattern, the face is identified as the successor.5.3 Benchmarking and Trade-offsImplementing robust TNP mitigation comes at a cost. The overhead of hashing and graph traversal increases regeneration time. Benchmarks indicate a ~30% increase in computation time (e.g., from 40s to 52s for complex assemblies).24 However, this is a necessary trade-off for model stability, preventing the "exploding model" syndrome.6. Analysis Situs and Active Data FrameworkAnalysis Situs provides an alternative architectural reference, utilizing the Active Data framework. This framework sits on top of OCAF, providing a simplified, strictly typed C++ API that enforces Directed Acyclic Graph (DAG) integrity.126.1 The Active Data Abstraction LayerActive Data abstracts TDF_Label into Nodes.ActData_BaseNode: The base class for all persistent objects. It wraps a TDF_Label and manages a collection of Parameters.ActData_Parameter: Wraps TDF_Attribute. Provides strict typing (ActData_IntParameter, ActData_ShapeParameter) and handles the read/write logic to the OCAF tree.6.2 The Explicit Dependency GraphUnlike FreeCAD, which often calculates dependencies implicitly, Active Data enforces an Explicit Dependency Graph via ActData_TreeFunction.12ActData_TreeFunction: A persistent object representing a node in the execution graph.Inputs: A list of TDataStd_Reference attributes pointing to data nodes.Outputs: A list of TDataStd_Reference attributes pointing to result nodes.ActData_TreeFunctionDriver: The algorithmic kernel. Each function type has a corresponding driver (Factory Pattern).Execution Flow:Trigger: User modifies a parameter.Analysis: The ActData_DependencyGraph traverses the reference links to build the execution list.Topological Sort: Determines the safe execution order.Driver Execution: The Execute() method is called for each function. It reads inputs from OCAF, runs the OCCT algorithm, and writes results back to OCAF.16Table 1: Architectural Comparison: FreeCAD vs. Analysis SitusFeatureFreeCAD (Realthunder)Analysis Situs (Active Data)Data ModelApp::DocumentObject (Python/C++)ActData_BaseNode (C++)Dependency LogicImplicit (Expression Engine + DAG)Explicit (ActData_TreeFunction Links)TNP SolutionElementMap + Topo HashingNaming Services + Explicit IDsPersistenceZip-compressed XML + BREPOCAF Binary (BinDrivers)Primary Use CaseParametric Design / ModelingGeometry Analysis / Algorithm Dev7. Advanced Persistence and SerializationThe history tree must be persistent. While OCAF handles native storage, interoperability requires modern web-friendly formats.7.1 Native OCAF PersistenceOCAF uses a driver-based persistence architecture.Storage Drivers: BinDrivers (Binary) and XmlDrivers (XML).Mechanism: The storage driver iterates the label hierarchy. For each attribute, it calls the corresponding attribute driver (e.g., TNaming_NamedShape::Store).19Shape Persistence: In recent OCCT versions (7.6+), BinTools is used for efficient B-Rep storage, replacing the older BRepTools. It supports fast binary dump of topology with reduced precision options for smaller file sizes.267.2 JSON and Web InteroperabilityModern workflows demand JSON export for web viewers (Three.js/Babylon.js).Challenge: TopoDS_Shape is complex binary data (NURBS curves, connectivity) that does not map cleanly to JSON.Solution: Hybrid Serialization.Structure: The Feature Tree (DAG) is serialized to JSON (Feature IDs, Parameters, Parent-Child links).Geometry: The B-Rep is meshed (BRepMesh_IncrementalMesh) and exported to a binary format like glTF (.glb) or OBJ.Reference: The JSON node references the glTF mesh file.277.3 glTF with MetadataStandard glTF only stores geometry. Parametric history requires metadata.Implementation: The RWGltf_CafWriter class in OCCT can be extended or configured to write OCAF attributes into the extras property of glTF nodes.Data Mapping:OCAF Label Name $\rightarrow$ glTF Node Name.OCAF User Attributes (Mass, Material) $\rightarrow$ glTF extras JSON object.Status: OCCT 7.8/7.9 is actively standardizing this "User Defined Attribute" export to improve BIM and CAD interoperability.298. Performance and ConcurrencyImplementing a history tree in C++ requires careful attention to performance, particularly memory management and multithreading.8.1 Memory Management with HandlesOCCT uses a reference-counting system similar to std::shared_ptr.Handle_Standard_Transient: The base class for all managed objects.Architecture: Data objects (Geometry, Attributes) are manipulated via Handles. When the reference count drops to zero, the memory is freed.Pitfall: Circular references in the DAG (Feature A referencing Feature B referencing Feature A) will prevent deletion. C++ implementations must use weak references or explicit "break" logic during document closure to resolve cycles.148.2 Parallel RegenerationThe DAG structure allows for Task-Based Parallelism.Graph Analysis: If Feature B and Feature C depend on Feature A but are independent of each other, they can be regenerated in parallel.Threading Libraries: OCCT integrates with Intel TBB (Threading Building Blocks).Thread Safety:Reading standard OCCT geometry is thread-safe.Writing to the OCAF Document is not thread-safe. The TDocStd_Document is a shared resource.Strategy: Compute geometry in parallel threads using local variables. Use a mutex-locked "Commit" step to write the resulting shapes back to the OCAF tree.318.3 Partial LoadingFor massive assemblies (10,000+ parts), loading the full history is prohibitive.Structure-Only Loading: OCAF supports loading only the Label hierarchy and Attributes, skipping the heavy TopoDS_Shape data.On-Demand Loading: The shape is loaded from disk only when the TNaming_NamedShape is accessed for visualization or algorithms. This requires a custom PCDM_RetrievalDriver implementation.179. ConclusionThe implementation of a Parametric Feature History Tree in C++ is a multidisciplinary engineering challenge that transcends simple geometric modeling. It requires:A Robust Data Backbone: Utilizing OCAF provides a proven, industrial-grade ECS structure for managing complex engineering data.Graph-Theoretic Rigor: Implementing the history as a DAG with rigorous cycle detection and topological sorting is non-negotiable for stability.Algorithmic Innovation for TNP: The standard "Index-Based" referencing is obsolete. Modern systems must implement Graph-Based Topological Hashing (as demonstrated by Realthunder's FreeCAD branch) to ensure model stability during parametric edits.Architectural Separation: The use of Command, Factory, and Observer patterns ensures that the algorithmic core is decoupled from the user interface and persistence layers.By adhering to these architectural principles and leveraging the advanced capabilities of the OpenCascade kernel, software engineers can construct CAD applications that are not only powerful in their modeling capabilities but resilient and scalable in their data management.10. Appendix: Data TablesTable 2: Comparison of Topological Naming StrategiesStrategyDescriptionRobustnessPerformance CostImplementation ComplexityIndex-BasedReferences entity by list index (e.g., Face(5)).Critical Failure on topology change.Negligible.Low.Geometric ProximityReferences entity by 3D point (e.g., center).Low. Fails on large dimensional changes.Low.Low/Medium.Ancestry TracingReferences entity by parent feature ID.Medium. Fails on splits/merges.Medium.Medium.Contextual HashingHashes topology graph (neighbors + history).High. Resilient to splits and geometry shifts.High (Graph traversal required).High (Requires deep kernel integration).Table 3: Recommended C++ Libraries for Parametric CADComponentLibraryRoleGeometric KernelOpenCascade (OCCT)B-Rep data structures, Boolean algos, Filleting.Data FrameworkOCCT OCAFLabel-Attribute tree, Undo/Redo, Persistence.Graph ManagementCustom / Active DataDependency logic, Dirty propagation, Cycle detection.ParallelismIntel TBBTask scheduling for parallel regeneration.SerializationRapidJSON / glTF SDKExporting metadata and web-ready geometry.Table 4: OCAF Attribute Mapping for Feature TreesFeature ComponentOCAF AttributeDescriptionResult GeometryTNaming_NamedShapeStores the topological result (B-Rep).Dependency LinkTDataStd_ReferencePointer to upstream Feature Label.Parameter (Float)TDataStd_RealStores dimensions (Length, Radius).Parameter (String)TDataStd_NameUser-defined name ("Pad1").SelectionTNaming_SelectorPersistent reference to sub-shape (Edge/Face).VisualizationTPrsStd_AISPresentationLink to 3D Viewer (AIS Context).End of Report.


---

# ChatGPT Research

Feature History Tree Architecture (C++ / OCCT)
A parametric feature tree represents each modeling step (sketch, extrude, boolean, fillet, pattern, etc.) as a node with parameters and outputs. In OneCAD’s case this includes all major operations in the spec (e.g. profile-based Extrude/Revolve, Boolean Union/Cut/Intersect, Push/Pull, Fillet/Chamfer/Shell, and Linear/Circular Patterns). We recommend modeling each operation as a distinct C++ Feature class (e.g. ExtrudeFeature, FilletFeature, etc.) inheriting from a common interface. Each feature holds: a unique ID, type, parameters (structured fields or a parameter map), references to input shapes (sketch profiles or bodies), and its output TopoDS_Shape. Features also track a list of dependent features (built via a directed acyclic dependency graph). The data model thus consists of a collection of Feature objects in a host Model or Document class. Internally the model maintains a DAG (not just a strict tree) of features to capture cross-feature references (e.g. one feature using the output of two parent features). In practice one can store the features in a vector (preserving creation order) and also build a graph of edges parent → child for dependencies. This allows topological sorting for deterministic rebuilds. Each feature’s output shape is cached (a TopoDS_Shape handle) so that unchanged features do not need recomputation. All feature classes should be modular and extensible (e.g. using a factory or registration pattern to add new types), enabling new feature types without modifying core logic. Key elements of the architecture include:
Feature classes: a base class (e.g. Feature) with virtual methods Execute() (to build the shape), GetDependencies(), Serialize()/Deserialize(), etc. Derived classes implement specifics (extrude, revolve, fillet, etc.) and know how to query OCCT builders.
Dependency graph: maintain for each feature which other feature(s) it uses (e.g. an Extrude uses the “Sketch” feature that produced a face). This can be a directed graph or adjacency list. We enforce a total ordering by doing a topological sort before rebuild. A stable ordering is achieved by assigning each feature a unique ID and sorting by DAG topology, so rebuilds are deterministic.
Modularity: features are ideally self-contained modules. Use C++17/20 idioms (smart pointers for memory, std::variant or property structs for parameters, etc.) to keep interfaces clean. For example, parameters may be simple numeric fields or a generic std::map<string,value> that is serialized as JSON/XML. New feature types can be registered via a factory method (given the type name or enum, return a new Feature object).
OCAF option: Optionally, one can leverage OCCT’s Application Framework (OCAF) to store the model. In OCAF, each feature could correspond to a TDF_Label with child attributes for parameters and TopoDS shapes. TNaming attributes (see below) can handle references. OCAF provides built-in Save/Restore, Undo/Redo and modification tracking
dev.opencascade.org
, which simplifies rollback. However, a custom lightweight data model using standard C++ containers may be sufficient and more transparent for a small CAD kernel.
Shape Modification Tracking (OCCT)
Every modeling operation in OCCT (BRepAlgoAPI, BRepFilletAPI, etc.) inherits from BRepBuilderAPI_MakeShape and automatically records which sub-shapes were generated, modified or deleted. We leverage this to maintain the feature history mapping. In practice, after executing an OCCT operation, use its Generated(), Modified(), and IsDeleted() methods to link old and new geometry. For example:
BRepAlgoAPI_Fuse fuseOp(toolShape, targetShape);
fuseOp.Build();
TopoDS_Shape result = fuseOp.Shape();
TopTools_ListOfShape newFaces = fuseOp.Generated(targetFace);  // faces generated from targetFace
Here fuseOp.Generated(someFace) returns the list of faces in the result that came from the given face. OCCT’s doc notes: “Generated() returns the list of shapes generated from the shape” and “Modified() returns the list of shapes modified from the shape”
dev.opencascade.org
dev.opencascade.org
. By querying Modified(oldSubshape), Generated(oldSubshape,newSubshape), etc., the feature can record exactly how each input shape evolved. This is critical for topological naming and for updating references when shapes change. A recommended pattern is to use OCCT’s TNaming (topological naming) framework (part of the Application Framework) to store these relationships. For each feature, create a TNaming_Builder on the feature’s data label (if using OCAF) or a similar container. Then call the builder’s methods:
TNaming_Builder builder(label);
builder.Delete(oldShape);           // record shapes removed by this operation
builder.Modify(oldShape, newShape); // record shapes that were modified
builder.Generated(oldShape, newShape); // record new shapes from old shapes
As the docs describe, TNaming_Builder::Modify(old,new) “records the shape newShape which is a modification of oldShape”, and Generated(old,new) “records newShape generated from oldShape”
dev.opencascade.org
dev.opencascade.org
. By doing this for every operation, any downstream feature can use TNaming selectors to re-find the correct sub-shapes even if geometry has changed (this is how robust referencing is achieved in OCCT-based parametric systems). The Application Framework’s built-in tracking (save/restore, undo/redo, change notifications) can also be used if the feature tree is stored in an OCAF document
dev.opencascade.org
. In a leaner implementation without full OCAF, one can manually record dependencies: each feature, after building its shape, inspects the builder’s lists of Modified and Generated shapes and updates its internal records or a global map from “old shape → new shape”. Then features referring to those shapes (by ID or pointer) can detect when their inputs have changed. The key is to integrate OCCT’s shape-tracking (BRepBuilderAPI) with the feature graph so that when a feature’s input (shape) is modified by an upstream feature, the dependency graph is updated accordingly.
Partial Regeneration and Update Strategy
To achieve real-time performance, we avoid rebuilding the entire model for every change. Instead, we implement partial regeneration via dirty-flag propagation on the feature graph. The approach is:
Change Detection: When a feature’s parameter is edited or its suppressed state toggled, mark that feature as “dirty.”
Propagate: Traverse the dependency graph outward: for every dirty feature, mark all downstream (dependent) features as dirty too, since they rely on its output.
Topological Rebuild: Sort the dirty subgraph topologically (respecting dependencies). Then re-execute each dirty feature in order. For a dirty feature, call its Execute() method (which runs the OCCT builder and updates its output shape). For a feature whose inputs haven’t changed (not dirty), skip rebuild and reuse its previous shape.
Caching: Each feature should cache its last output shape. If a feature is clean (no inputs changed), it simply keeps that cached shape. This avoids unnecessary recomputation. OCCT shapes (TopoDS_Shape) are handle-based, so preserving a shape handle automatically preserves its geometry.
Delta Update (optional): For some features (like moving a sketch in-plane), it may be possible to do a fast local update instead of full rebuild. This can be an optimization path but is not required for correctness.
This selective update ensures minimal work. As the T-FLEX CAD documentation notes, “Partial regeneration saves time. The system automatically analyzes what objects were modified… and recalculates these objects and their children only.”
tflex.com
. We follow the same idea: only dirty features (and those downstream) are recalculated. For implementation, use a graph algorithm or observer pattern. For example, keep for each feature a list of “child” features that depend on it. When a feature changes, push it on a queue, then for each outgoing edge mark the target child dirty and repeat. After marking, perform a depth-first or breadth-first topological pass to rebuild. C++ idioms: one can use a std::set of dirty feature pointers and repeatedly pick the next whose dependencies are all clean (or use an index of in-degree). Deterministic rebuild ordering is ensured by the graph’s structure and stable feature IDs. For a given set of changes, sorting the dirty nodes by ID (or insertion order) within each dependency level guarantees repeatable order. Combined with OCCT’s own deterministic algorithms, this yields a reproducible rebuild.
Failure Rollback and Suppression
Robustness requires handling failed feature builds and optional suppression. If an OCCT operation throws an exception or returns an invalid result (e.g. self-intersecting profile for extrude), we should roll back to the last good state. In practice, wrap each feature execution in try/catch. Before execution, one can copy or snapshot its previous output shape (and any affected children). If the build fails, restore the old shape and mark the feature as “in error” (so dependents know to handle it). OCAF can simplify this via transactions: begin an undo transaction before rebuilding, and if failure occurs, abort the transaction to revert all changes. In a custom model, simply reassign the old TopoDS_Shape and clear the dirty flags to stop further propagation. One might also mark the feature as suppressed or disabled to prevent it affecting others. Feature suppression means toggling a feature off without deleting it. When suppressed, the feature’s Execute() should be a no-op: its output is either set to an identity shape or to its input shape (e.g. skip an extrude by treating distance=0). Downstream features must then treat that input accordingly. Suppressed features should be included in the graph (so disabling one feature automatically makes its children dirty and they’ll rebuild with the now-skipped input). In UI terms the user might “turn off” a feature; internally this just means skipping its operation. All these behaviors (exceptions, suppression) are managed on the backend: the model code never crashes the app but flags features as dirty, error, or disabled.
Serialization (JSON/XML Format)
The feature tree must be saved/loaded in a structured file format. A human-readable yet efficient choice is JSON (or XML), with a clear schema. For example, the file could be an object like:
{
  "version": 1,
  "units": "mm",
  "features": [
    {"id":1, "type":"Sketch", "params":{...}, "output": "face:1"},
    {"id":2, "type":"Extrude", "params":{"distance":10, "direction":[0,0,1]}, "inputSketch":1, "output":"solid:2"},
    {"id":3, "type":"Fillet", "params":{"radius":5}, "inputSolid":2}
  ]
}
Each feature record includes its unique id, the operation type, a parameter block, and references to other features’ outputs (here by ID). Textual names and clear field labels make JSON easy to read/edit. We suggest embedding the dependency references by ID (so features can be linked on load). Use arrays or objects consistently so adding new fields (e.g. “patternCount” in a future update) won’t break older parsers. A version number at top allows format evolution. XML is an alternative (e.g. each feature as <Feature id="..." type="Extrude">…</Feature>), but JSON is generally more compact and widely supported in modern C++. Both support schema validation if needed. For extensibility, avoid rigid ordering: each feature’s type determines which params are expected, and unknown JSON fields can be ignored by the parser (or stored as “userData” for forward compatibility). Use numeric IDs or GUID strings rather than pointer addresses. Efficient loading: A JSON parser (like nlohmann::json in C++) can quickly build a DOM or map directly into feature objects. Since parameters are typically just numbers or strings, deserialization is fast. For large assemblies, binary formats or protocol buffers could be considered later, but textual JSON/XML suffices for v1. Importantly, the file need not store the full mesh – it stores feature definitions. The actual geometry is reconstructed on load by replaying the features in order (or via a cached pre-built shape if desired). In summary, the system stores a feature graph with typed nodes (extrudes, booleans, etc.) in C++ objects, uses OCCT’s BRepBuilderAPI to perform each operation and record which sub-shapes were created/modified
dev.opencascade.org
dev.opencascade.org
, propagates updates through the dependency graph for partial rebuilds, and serializes the tree to JSON/XML for persistence. This design ensures modularity (new features are new classes), robustness (using TNaming or explicit shape tracking for valid references), and efficiency (caching outputs and only recomputing changed branches). Sources: OCCT docs and community resources on topological naming (Modified/Generated/Deleted) and the Application Framework
dev.opencascade.org
dev.opencascade.org
dev.opencascade.org
dev.opencascade.org
, as well as CAD references on feature history and partial regeneration
tflex.com
tflex.com
. These illustrate best practices for a parametric feature tree in a C++/OCCT kernel.
Citácie
SPECIFICATION.md

file://file_00000000acd071f5ad898a201563bc53
SPECIFICATION.md

file://file_00000000acd071f5ad898a201563bc53

Open CASCADE Technology: Introduction

https://dev.opencascade.org/doc/overview/html/

Open CASCADE Technology: BRepBuilderAPI_MakeShape Class Reference

https://dev.opencascade.org/doc/refman/html/class_b_rep_builder_a_p_i___make_shape.html

Open CASCADE Technology: BRepBuilderAPI_MakeShape Class Reference

https://dev.opencascade.org/doc/refman/html/class_b_rep_builder_a_p_i___make_shape.html

Open CASCADE Technology: TNaming_Builder Class Reference

https://dev.opencascade.org/doc/refman/html/class_t_naming___builder.html

Open CASCADE Technology: TNaming_Builder Class Reference

https://dev.opencascade.org/doc/refman/html/class_t_naming___builder.html

Basic Terms and Concepts of 3D Modeling > Approaching Solid Modeling with T-FLEX CAD 3D

https://www.tflex.com/help/eng/T-FLEX%20CAD/15/solid_modeling.htm

Basic Terms and Concepts of 3D Modeling > Approaching Solid Modeling with T-FLEX CAD 3D

https://www.tflex.com/help/eng/T-FLEX%20CAD/15/solid_modeling.htm